#June7
from PySide import QtCore, QtGui
from shiboken import wrapInstance
import maya.OpenMayaUI as apiUI
import sys


def getMayaWindow():
    """
    Get the main Maya window as a QtGui.QMainWindow instance
    @return: QtGui.QMainWindow instance of the top level Maya windows
    """
    ptr = apiUI.MQtUtil.mainWindow()
    if ptr is not None:
        return wrapInstance(long(ptr), QtGui.QMainWindow)
        
class AutoArmGUI(QtGui.QDialog):
    def __init__(self,  parent=getMayaWindow()):
        super(AutoArmGUI, self).__init__(parent)
        self.initUI()
         
    def initUI(self):
        # layout
        self.setLayout(QtGui.QVBoxLayout())
        self.setWindowTitle("Auto Arm")
        # add tabs          
        self.layout().addWidget(MyButtons())
        self.show()
        
        
class MyButtons(QtGui.QWidget):
    def __init__(self, parent=None):
        super(MyButtons, self).__init__(parent)
        
        # layout
        self.setLayout(QtGui.QVBoxLayout())

        # buttons
        self.edittext = QtGui.QLineEdit("Enter Name")
        self.layout().addWidget(self.edittext)
        self.chbox_bend = QtGui.QCheckBox("Bendy")
       # self.layout().addWidget(self.chbox_bend)
        self.chbox_stretchy = QtGui.QCheckBox("Stretchy")
        self.layout().addWidget(self.chbox_stretchy)
        self.chbox_x = QtGui.QCheckBox("X")
        self.layout().addWidget(self.chbox_x)
        self.chbox_y = QtGui.QCheckBox("Y")
        self.layout().addWidget(self.chbox_y)
        self.chbox_z = QtGui.QCheckBox("Z")
        self.layout().addWidget(self.chbox_z)
        btn =QtGui.QPushButton("Go!")
        self.layout().addWidget(btn)
        btn.clicked.connect(self.buttonClicked)
                                        
        
    def buttonClicked(self):
        inputText = self.edittext.text()
        print inputText
        


        ####################
        ### Arm-rig code ###
        ####################
             

        jointList = cmds.ls(orderedSelection = True)
        jointList2 = cmds.ls()
        UserIn = inputText
        cmds.group(em = True, n = UserIn + '_grp')
        cmds.group(em = True, n = UserIn + '_controls01')
        cmds.group(em = True, n= UserIn + '_skeleton01' )
        
  
        if self.chbox_y.isChecked():
            inputD = 'Y'
        #set preferred angle
        cmds.rotate( '4deg', 0, 0, jointList[1] )
        cmds.joint(jointList[1], e=True, spa=True) 
        cmds.rotate( 0, 0, 0, jointList[1] )

        if self.chbox_z.isChecked():
            inputD = 'Z'
        if self.chbox_x.isChecked():
            inputD = 'X'
        
        firstJoint = jointList[0]
        lastJoint = jointList[-1]
        

          
        #IK / FK Switch: creating control 
        controlC = cmds.circle(nr=(0,1,0), c=(0, 0, 0), r=10, n=UserIn + '_arm_anim')
        ikfk_attr = cmds.addAttr(controlC, longName='IKFK', attributeType='float', defaultValue = 1, k=True )

                   
        #Parents joint to previous using Index & retrieve value for first and last jt. 
        for everyobj in jointList:
            if jointList.index(everyobj) != 0:
                indexNum = jointList.index(everyobj)
                lowerNum = indexNum - 1
                cmds.parent( jointList[indexNum], jointList[lowerNum] )           

        fkcontrolList = []
        #FK Set up (off by default) 
        for everyobj in jointList:
            nameC = everyobj + '_anim'
            fkcontrolList.append(nameC)

            #cmds.rename(everyobj, UserIn + '_jnt')
            cmds.circle(nr=(0,1,0), c=(0, 0, 0), r=10, n= nameC) 
            cmds.parentConstraint(everyobj, nameC)
            cmds.parentConstraint(everyobj, nameC, rm = True)
            cmds.orientConstraint(nameC, everyobj, w=1, mo = True)      
         
                            
      
                
            #IK / FK Switch: FK connections to condition 
            condNode = cmds.shadingNode('condition', asUtility=True)
            cmds.setAttr(condNode + ".firstTerm", 0) 
            cmds.setAttr(condNode + ".secondTerm", 1) 
            cmds.connectAttr(UserIn + '_arm_anim.IKFK', condNode + '.firstTerm')
            cmds.connectAttr(condNode + '.outColorR', nameC  +  '.visibility')
            #Set Driven Keys
            cmds.setDrivenKeyframe( everyobj + '_orientConstraint1.' + nameC +'W0', cd = UserIn +'_arm_anim.IKFK', dv = 0, v = 1 )
            cmds.setDrivenKeyframe( everyobj + '_orientConstraint1.' + nameC +'W0', cd = UserIn + '_arm_anim.IKFK', dv = 1, v = 0 )
                
        #parent control under each other for fk  
        for everyobj in fkcontrolList:           
            if fkcontrolList.index(everyobj) != 0:
                indexNum2 = fkcontrolList.index(everyobj) 
                lowerNum2 = indexNum2 - 1               
                cmds.parent( fkcontrolList[indexNum2], fkcontrolList[lowerNum2] ) 
        #IK & anim control set up
        if self.chbox_y.isChecked():
            cmds.rotate( '20deg', 0, 0, jointList[1] )
            cmds.joint(jointList[1], e=True, spa=True, ch=True) 
            cmds.rotate( 0, 0, 0, jointList[1] )
        cmds.ikHandle( sj=firstJoint, ee=lastJoint, sol= 'ikRPsolver', n = UserIn + 'ikRPS_name' )
        cmds.parentConstraint(lastJoint, controlC)
        cmds.parentConstraint(lastJoint, controlC, rm = True)
        cmds.parentConstraint(controlC, UserIn + 'ikRPS_name', w=1, mo = True)
        #distance of leg
        distline01 = distanceCalc(jointList[0],jointList[1])
        distline02 = distanceCalc(jointList[1],jointList[2])
        d_calc = distline01 + distline02
        
        #set up pole vector, need to clean up so it works in any direction
        cmds.spaceLocator(n = UserIn + '_anim_loc')
        cmds.pointConstraint('joint2', UserIn + '_anim_loc')
        cmds.pointConstraint('joint2', UserIn + '_anim_loc', rm = True)
        if self.chbox_y.isChecked():
            cmds.move( 0, 0, d_calc, UserIn + '_anim_loc', r=True )
     

        if self.chbox_z.isChecked():
            cmds.move( 0, d_calc, 0, UserIn + '_anim_loc', r=True )
        if self.chbox_x.isChecked():
            cmds.move( d_calc, 0, 0, UserIn + '_anim_loc', r=True )
        cmds.makeIdentity(UserIn + '_anim_loc', apply=True, translate=True, rotate=True, scale=True )
        cmds.poleVectorConstraint( UserIn + '_anim_loc', UserIn + 'ikRPS_name' )
        

        #IK Switch: Ik connections 
        cmds.connectAttr(UserIn + '_arm_anim.IKFK', UserIn + '_arm_anim.visibility')
        cmds.connectAttr(UserIn + '_arm_anim.IKFK', UserIn + '_anim_loc.visibility')
        cmds.connectAttr(UserIn + '_arm_anim.IKFK', UserIn + 'ikRPS_name.ikBlend')
               
        
        #cleanUp
        cmds.parent( fkcontrolList[0], UserIn + '_controls01' )
        cmds.parent( firstJoint, UserIn + '_skeleton01' )
        cmds.parent(UserIn + '_arm_anim', UserIn + '_controls01')
        cmds.parent(UserIn + '_anim_loc', UserIn + '_controls01')
        cmds.parent(UserIn + 'ikRPS_name',UserIn + '_grp')
        cmds.parent(UserIn + '_controls01',UserIn + '_grp')
        cmds.parent(UserIn + '_skeleton01',UserIn + '_grp')
        

       
        ###################
       ### Add Stretchy ####
        ###################
        if self.chbox_stretchy.isChecked():
            print 'STRETCHY IS ON'
            distDim = cmds.distanceDimension( sp=(0, 2, 2), ep=(1, 5, 6))
            listDistLoc = cmds.listConnections(distDim)
            cmds.pointConstraint(firstJoint, listDistLoc[0], mo = False)
            cmds.pointConstraint(UserIn + '_arm_anim', listDistLoc[1], mo = False)
            cmds.shadingNode ('multiplyDivide', n = UserIn + 'multDivid', asUtility=True)
            cmds.shadingNode ('condition', n = UserIn + 'STREcondNod', asUtility=True)
            cmds.connectAttr(distDim + '.distance',UserIn +'multDivid.input1' + inputD)
            cmds.connectAttr(distDim + '.distance', UserIn +'STREcondNod.firstTerm')
            cmds.connectAttr(UserIn +'multDivid.output'+ inputD, UserIn +'STREcondNod.colorIfTrueR')
            cmds.setAttr(UserIn +'multDivid.operation', 2)
            cmds.setAttr(UserIn +'STREcondNod.operation', 2)

            firstJointLoc = cmds.xform(jointList[0], query=True, translation=True, worldSpace=True )
            firstjt_Y = firstJointLoc[1]

            
            cmds.setAttr(UserIn + 'multDivid.input2'+ inputD, d_calc)
            cmds.setAttr(UserIn + 'STREcondNod.secondTerm', d_calc)
            
            print d_calc
           
            for joints in jointList:
                cmds.connectAttr(UserIn + 'STREcondNod.outColorR', joints+'.scale'+ inputD)
                 



            
        ###################
       ### Add Bendy ####
        ###################            
                        
        if self.chbox_bend.isChecked():
            print 'Bendy IS ON'            
def distanceCalc(jt01, jt02):
    Point1 = cmds.xform(jt01, query=True, translation=True, worldSpace=True )
    Point2 = cmds.xform(jt02, query=True, translation=True, worldSpace=True )
    

    
    j1_valX = Point1[0]
    j1_valY = Point1[1] 
    j1_valZ = Point1[2]
    
    j2_valX = Point2[0]
    j2_valY = Point2[1]
    j2_valZ = Point2[2]
    
 
    dist = (j2_valX - j1_valX)**2 + (j2_valY - j1_valY)**2 +(j2_valZ-j1_valZ)**2 
 
    if dist < 0:
           dist = dist*-1
    return dist**(1/2.0)
    
                 
ex = AutoArmGUI()
 
